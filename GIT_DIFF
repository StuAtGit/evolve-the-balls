diff --git a/GlobalMakeSettings.mk b/GlobalMakeSettings.mk
index a671e17..aa64775 100644
--- a/GlobalMakeSettings.mk
+++ b/GlobalMakeSettings.mk
@@ -32,11 +32,6 @@ RENDERER_LOCATION=$(EVOLVE_HOME)/utilityFiles/renderer
 #lsystem includes
 SYSTEM_LOCATION=$(EVOLVE_HOME)/system
 LSYSTEM_LOCATION=$(EVOLVE_HOME)/system/lSystem
-#Physics includes
-PhysicsEngine_Location=$(EVOLVE_HOME)/physicsEngine
-#World object includes
-WorldObject_Location=$(EVOLVE_HOME)/worldObject
-StaticWorldObject_Location=$(WorldObject_Location)/staticWorldObject
 #client/server includes
 SERVER_LOCATION=$(EVOLVE_HOME)/server
 COMMANDHANDLER_LOCATION=$(EVOLVE_HOME)/server/commandHandler
@@ -57,8 +52,7 @@ CCFLAGS=-I./ -I$(UTILITY_LOCATION) -I$(LSYSTEM_LOCATION) \
 		 -I$(SERVER_LOCATION) -I$(SYSTEMCOMMANDHANDLER_LOCATION) \
 		 -I$(SYSTEM_LOCATION) -I$(LSYSTEMINTERPRETER_LOCATION)\
 		 -I$(INTERPRETER_LOCATION) -I$(MATRIX_LOCATION)\
-		 -I$(RENDERER_LOCATION) -I$(PhysicsEngine_Location) -I$(WorldObject_Location)\
-		 -I$(StaticWorldObject_Location)\
+		 -I$(RENDERER_LOCATION)\
 		 -I$(OGRE_INCLUDE_LOCATION) -I$(OGRE_EXAMPLE_LOCATION)\
 		 -I$(Ois_Include_Location)\
 		  -ggdb3 -Wall -O2 
@@ -68,16 +62,13 @@ CCFLAGS=-I./ -I$(UTILITY_LOCATION) -I$(LSYSTEM_LOCATION) \
 ODE=libode.a
 #Ogre
 LIB_OGREMAIN=libOgreMain-1.4.0.so
-#LIB_OGREPLATFORM=libOgrePlatform.so.0
+LIB_OGREPLATFORM=libOgrePlatform.so.0
 Lib_OgreRenderer=RenderSystem_GL.so
 Lib_OgreParticlePlugin=Plugin_ParticleFX.so
 Lib_OgreBSPPlugin=Plugin_BSPSceneManager.so
 Lib_OgreOctreePlugin=Plugin_OctreeSceneManager.so
-Ogre=$(LIB_OGREMAIN) $(Lib_OgreRenderer) $(Lib_OgreParticlePlugin) $(Lib_OgreBSPPlugin) $(Lib_OgreOctreePlugin) 
 #Ois
 Lib_Ois=libOIS-1.0.0.so
-#ODE
-Ode=$(ODE) -lode
 #SDL
 Lib_SDL=libSDL-1.2.so.0
 #utility/misc objects
@@ -93,11 +84,6 @@ COMMANDS=Commands.o
 LSYSTEMGENERIC=LSystemGeneric.o
 #interpreter objects
 LSYSTEMGENERICINTERPRETER=LSystemGenericInterpreter.o
-#physics objects
-PhysicsEngine=PhysicsEngine.o
-#World objects
-WorldObject=WorldObject.o
-StaticWorldObject=StaticWorldObject.o
 #client/server objects
 SERVER=Server.o
 COMMANDHANDLER=CommandHandler.o
diff --git a/GlobalMakeTargets.mk b/GlobalMakeTargets.mk
index c328704..bc65ff0 100644
--- a/GlobalMakeTargets.mk
+++ b/GlobalMakeTargets.mk
@@ -66,18 +66,6 @@ $(LSYSTEMGENERICINTERPRETER):
 	cd $(LSYSTEMINTERPRETER_LOCATION) && make $(LSYSTEMGENERICINTERPRETER);
 	ln -s $(LSYSTEMINTERPRETER_LOCATION)/$(LSYSTEMGENERICINTERPRETER) $(LSYSTEMGENERICINTERPRETER);
 
-$(PhysicsEngine):
-	cd $(PhysicsEngine_Location) && make $(PhysicsEngine);
-	ln -s $(PhysicsEngine_Location)/$(PhysicsEngine) $(PhysicsEngine);
-
-$(WorldObject):
-	cd $(WorldObject_Location) && make $(WorldObject);
-	ln -s $(WorldObject_Location)/$(WorldObject) $(WorldObject);
-
-$(StaticWorldObject):
-	cd $(StaticWorldObject_Location) && make $(StaticWorldObject);
-	ln -s $(StaticWorldObject_Location)/$(StaticWorldObject) $(StaticWorldObject);
-
 $(LIB_RENDERER):
 	cd $(RENDERER_LOCATION) && make $(LIB_RENDERER);
 	ln -s $(RENDERER_LOCATION)/$(LIB_RENDERER) $(LIB_RENDERER);
diff --git a/MakefileStub b/MakefileStub
index cce9ff0..978d9d3 100644
--- a/MakefileStub
+++ b/MakefileStub
@@ -8,7 +8,7 @@ OBJ_CC=ObjX.cc
 
 all:$(TEST_DEPENDS) $(TEST)
 
-TEST_DEPENDS=$(LOGGER) $(COMMONASPECT) $(OBJ)
+TEST_DEPENDS=$(LOGGER) $(COMMON_ASPECT) $(OBJ)
 
 $(TEST):$(TEST_CC) $(TEST_DEPENDS)
 	$(CC) $(CCFLAGS) $(TEST_DEPENDS) $(TEST_CC) -o $(TEST)
diff --git a/ogreRenderer/Makefile b/ogreRenderer/Makefile
index 8a71be1..8502af1 100644
--- a/ogreRenderer/Makefile
+++ b/ogreRenderer/Makefile
@@ -6,12 +6,18 @@ TEST=testRenderer
 TEST_CC=testRenderer.cc
 OBJ=OISFrame.o
 OBJ_CC=OISFrame.cc
+PHY_OBJ=PhysicsEngine.o
+PHY_CC=PhysicsEngine.cc
 GDK_OBJ=OgreGDKCodec.o
 GDK_CC=OgreGDKCodec.cc
 Ois_Learn=oisLearn
 Ois_Learn_cc=oisLearn.cc
 StandardCamera=StandardCamera.o
 StandardCamera_cc=StandardCamera.cc
+WorldObject = WorldObject.o
+WorldObject_cc = WorldObject.cc
+StaticWorldObject = StaticWorldObject.o
+StaticWorldObject_cc = StaticWorldObject.cc
 OgreRendererObject = OgreRenderer.o
 OgreRenderer_cc = OgreRenderer.cc
 
@@ -20,24 +26,32 @@ CCFLAGS += `pkg-config --cflags --libs gtk+-2.0` -DGTK_MULTIHEAD_SAFE=1
 all:$(TEST_DEPENDS) $(TEST)
 
 #we don't put ogre plugins folder because we use TEST_DEPENDS with CC
-TEST_DEPENDS=$(OBJ) $(LOGGER) $(COMMONASPECT) $(PhysicsEngine)\
-			 $(GDK_OBJ) $(LIB_OGREMAIN)\
+TEST_DEPENDS=$(OBJ) $(PHY_OBJ) $(LOGGER) $(COMMONASPECT) $(GDK_OBJ) $(LIB_OGREMAIN)\
 			 $(Lib_OgreRenderer) $(Lib_OgreParticlePlugin) $(Lib_OgreBSPPlugin)\
 			 $(Lib_OgreOctreePlugin) $(Lib_SDL) $(ODE) $(Lib_Ois)\
 			 $(StandardCamera) $(WorldObject) $(StaticWorldObject)\
 			 $(OgreRendererObject) 
 
 $(TEST):$(TEST_CC) $(TEST_DEPENDS)
-	$(CC) $(CCFLAGS) $(TEST_DEPENDS) -lode $(TEST_CC) -o $(TEST)
+	$(CC) $(CCFLAGS) $(TEST_DEPENDS) $(TEST_CC) -lode -o $(TEST)
 
 include ../GlobalMakeTargets.mk
 
 $(OBJ):$(OBJ_CC)
 	$(CC) $(CCFLAGS) -c $(OBJ_CC) -o $(OBJ)
 
+$(PHY_OBJ):$(PHY_CC)
+	$(CC) $(CCFLAGS) -c $(PHY_CC) -o $(PHY_OBJ)
+
 $(StandardCamera):$(StandardCamera_cc)
 	$(CC) $(CCFLAGS) -c $(StandardCamera_cc) -o $(StandardCamera)
 
+$(WorldObject):$(WorldObject_cc)
+	$(CC) $(CCFLAGS) -c $(WorldObject_cc) -o $(WorldObject)
+
+$(StaticWorldObject):$(StaticWorldObject_cc)
+	$(CC) $(CCFLAGS) -c $(StaticWorldObject_cc) -o $(StaticWorldObject)
+
 $(OgreRendererObject):$(OgreRenderer_cc)
 	$(CC) $(CCFLAGS) -c $(OgreRenderer_cc) -o $(OgreRendererObject)
 
diff --git a/ogreRenderer/PhysicsEngine.cc b/ogreRenderer/PhysicsEngine.cc
new file mode 100644
index 0000000..f332458
--- /dev/null
+++ b/ogreRenderer/PhysicsEngine.cc
@@ -0,0 +1,282 @@
+#ifndef STU_PHYSICS_ENGINE_CC
+#define STU_PHYSICS_ENGINE_CC
+
+#include "PhysicsEngine.h"
+
+PhysicsEngine::PhysicsEngine()
+{
+    this->worldId = dWorldCreate();
+    this->spaceId = dHashSpaceCreate( 0 );
+    this->contactJointGroup = dJointGroupCreate( 0 );
+    dWorldSetGravity( this->worldId, 0, 0, 0 );
+}
+
+bool PhysicsEngine::addItem( const string& name, const vector<double>& pos, double radius )
+{
+    logger.print( "Notify: entered Physics::addItem", this->doNotify );
+    if( bodies.find( name ) != bodies.end() )
+    {
+        //logger.print( "Warning: in PhysicsEngine::addItem attempted to add a body to the physics engine with a duplicate name of: " + name );
+        return false;
+    }
+
+    if( pos.size() < 3 )
+    {
+        logger.print( "Warning: in PhysicsEngine::addItem, passed a position vector with a size < 3" );
+        return false;
+    }
+
+    dGeomID geometry = dCreateSphere( this->spaceId, radius );
+    dBodyID body = dBodyCreate(this->worldId);
+    dGeomSetBody( geometry, body );
+    dBodySetPosition( body, pos[0], pos[1], pos[2] );
+    bodies[name] = body;
+    return true;
+}
+
+bool PhysicsEngine::addItem( const string& name, const vector<double>& pos, double edgex, double edgey, double edgez )
+{
+    logger.print( "Notify: entered Physics::addStaticItem", this->doNotify );
+    if( bodies.find( name ) != bodies.end() )
+    {
+        logger.print( "Warning: in PhysicsEngine::addStaticItem attempted to add a body to the physics engine with a duplicate name of: " + name );
+        return false;
+    }
+
+    if( pos.size() < 3 )
+    {
+        logger.print( "Warning: in PhysicsEngine::addStaticItem, passed a position vector with a size < 3" );
+        return false;
+    }
+    dGeomID geometry = dCreateBox( this->spaceId, edgex, edgey, edgez );
+    dBodyID body = dBodyCreate( this->worldId );
+    dGeomSetBody( geometry, body ); //0 means static body (no rigid body associated with it)
+    dBodySetPosition( body, pos[0], pos[1], pos[2] );
+    this->bodies[name] = body;
+    return true;
+}
+
+
+bool PhysicsEngine::addStaticItem( const string& name, const vector<double>& pos, double edgex, double edgey, double edgez )
+{
+    logger.print( "Notify: entered Physics::addStaticItem", this->doNotify );
+    if( bodies.find( name ) != bodies.end() )
+    {
+        logger.print( "Warning: in PhysicsEngine::addStaticItem attempted to add a body to the physics engine with a duplicate name of: " + name );
+        return false;
+    }
+
+    if( pos.size() < 3 )
+    {
+        logger.print( "Warning: in PhysicsEngine::addStaticItem, passed a position vector with a size < 3" );
+        return false;
+    }
+    dGeomID geometry = dCreateBox( this->spaceId, edgex, edgey, edgez );
+    dGeomSetBody( geometry, 0 ); //0 means static body (no rigid body associated with it)
+    dGeomSetPosition( geometry, pos[0], pos[1], pos[2] );
+    this->geometries[name] = geometry;
+    return true;
+}
+
+bool PhysicsEngine::addStaticItem( const string& name, const vector<double>& pos, double radius )
+{
+    logger.print( "Notify: entered Physics::addStaticItem", this->doNotify );
+    if( bodies.find( name ) != bodies.end() )
+    {
+        logger.print( "Warning: in PhysicsEngine::addStaticItem attempted to add a body to the physics engine with a duplicate name of: " + name );
+        return false;
+    }
+
+    if( pos.size() < 3 )
+    {
+        logger.print( "Warning: in PhysicsEngine::addStaticItem, passed a position vector with a size < 3" );
+        return false;
+    }
+    dGeomID geometry = dCreateSphere( this->spaceId, radius );
+    dGeomSetBody( geometry, 0 ); //0 means static body (no rigid body associated with it)
+    dGeomSetPosition( geometry, pos[0], pos[1], pos[2] );
+    this->geometries[name] = geometry;
+    return true;
+}
+
+bool PhysicsEngine::removeItem( const string& name )
+{
+    if( bodies.find( name ) == bodies.end() and geometries.find( name ) == geometries.end() )
+    {
+        logger.print( "Notify: in PhysicsEngine, attempt to remove an item " + name + " that does not exist", this->doNotify );
+        return false;
+    }
+
+    if( bodies.find( name ) != bodies.end() )
+    {
+        dBodyDestroy( this->bodies[name] );
+        this->bodies.erase(name);
+    }
+    if( geometries.find( name ) != geometries.end() )
+    {
+        dGeomDestroy( this->geometries[name] );
+        this->geometries.erase(name);
+    }
+    return true;
+}
+
+bool PhysicsEngine::setGravity( double x, double y, double z )
+{
+    dWorldSetGravity( this->worldId, x, y, z );
+    return true;
+}
+
+bool PhysicsEngine::setPosition( const string& name, const vector<double>& position )
+{
+    logger.print( "Notify: entered Physics::setPosition", this->doNotify );
+    if( bodies.find( name ) == bodies.end() )
+    {
+        logger.print( "Notify: in PhysicsEngine::setPosition attempted to set the position of a body that does not exist, the name tried was: " + name, this->doNotify );
+        return false;
+    }
+
+    if( position.size() < 3 )
+    {
+        logger.print( "Warning: Oop! we only support objects in a 3-manifold\n" +
+                      string("Warning: (Your position vector in PhysicsEngine::updateItemPosition had a size < 3)") );
+    }
+
+    dBodySetPosition( bodies[name], position[0], position[1], position[2] );
+    return true;
+}
+
+bool PhysicsEngine::setPosition( const string& name, double x, double y, double z )
+{
+    logger.print( "Notify: entered Physics::setPosition(x,y,z)", this->doNotify );
+    if( bodies.find( name ) == bodies.end() )
+    {
+        logger.print( "Notify: in PhysicsEngine::setPosition(x,y,z) attempted to set the position of a body that does not exist, the name tried was: " + name, this->doNotify );
+        return false;
+    }
+
+    dBodySetPosition( bodies[name], x, y, z );
+    return true;
+}
+
+bool PhysicsEngine::setMass( const string& name, double mass )
+{
+    logger.print( "Notify: entered Physics::setMass", this->doNotify );
+    if( bodies.find( name ) == bodies.end() )
+    {
+        logger.print( "Notify: in PhysicsEngine::setMass, attempted to set the mass of a body that does not exist, the name tried was: " + name, this->doNotify );
+        return false;
+    }
+
+    dMass dmass;
+    dMassSetZero( &dmass );
+    dmass.mass = mass;
+    dBodySetMass( bodies[name], &dmass );
+    return true;
+
+}
+
+bool PhysicsEngine::setLinearVelocity( const string& name, const vector<double>& vel )
+{
+    logger.print( "Notify: entered Physics::setLinearVelocity", this->doNotify );
+    if( bodies.find( name ) == bodies.end() )
+    {
+        logger.print( "Notify: in PhysicsEngine::setLinearVelocity attempted to set the linear velocity of a body that does not exist, the name tried was: " + name, this->doNotify );
+        return false;
+    }
+
+    if( vel.size() < 3 )
+    {
+        logger.print( "Warning: in PhysicsEngine::setLinearVelocity, passed a velocity vector with a size < 3" );
+        return false;
+    }
+
+    dBodySetLinearVel( bodies[name], vel[0], vel[1], vel[2] );
+    return true;
+
+}
+
+bool PhysicsEngine::getPosition( const string& name, vector<double>& pos )
+{
+    logger.print( "Notify: entered Physics::getPosition", this->doNotify );
+    if( this->bodies.find( name ) == this->bodies.end() && 
+        this->geometries.find( name ) == this->geometries.end()  )
+    {
+        //this happens often enough that we don't bother with warning
+        logger.print( "Notify: in PhysicsEngine::getPosition(x,y,z) attempted to get the position of a body/geom that does not exist, the name tried was: " + name, this->doNotify );
+        return false;
+    }
+
+    if( this->bodies.find( name ) != this->bodies.end() )
+    {
+        const dReal* phy_pos = dBodyGetPosition( this->bodies[name] );
+        pos.push_back( phy_pos[0] );
+        pos.push_back( phy_pos[1] );
+        pos.push_back( phy_pos[2] );
+    }
+    else
+    {
+        const dReal* phy_pos = dGeomGetPosition( this->geometries[name] );
+        pos.push_back( phy_pos[0] );
+        pos.push_back( phy_pos[1] );
+        pos.push_back( phy_pos[2] );
+    }
+    return true;
+}
+
+
+bool PhysicsEngine::getGravity( vector<double>& grav )
+{
+    dVector3 odeGrav;
+    dWorldGetGravity( this->worldId, odeGrav );
+    grav.push_back( odeGrav[0] );
+    grav.push_back( odeGrav[1] );
+    grav.push_back( odeGrav[2] );
+    return true;
+}
+
+bool PhysicsEngine::doPhysics()
+{
+    dSpaceCollide( this->spaceId, this, &nearCollisionCallback );
+    dWorldQuickStep( this->worldId, 1 );
+    dJointGroupEmpty( this->contactJointGroup );
+    return true;
+}
+
+/*
+ * callback for ODE. friend of PhysicsEngine. _this is meant to be 
+ * a this pointer at the PhysicsEngine object currently using the callback.
+ */
+void nearCollisionCallback( void* _this, dGeomID id1, dGeomID id2 )
+{
+    dBodyID b1 = dGeomGetBody( id1 );
+    dBodyID b2 = dGeomGetBody( id2 );
+
+    //if( b1 && b2 && dAreConnectedExcluding( b1, b2, dJointTypeContact ) )
+    //    return;
+
+    //TODO: ...
+    //er, technically the second argument to dCollide is a "flag" whose lower 
+    //16 bits is an integer with the max number of contacts. And the upper 16 bits
+    //are "Reserved for future use". Yup, that's right.
+    //Heck, these guys should write an RFC
+    short max_contacts = 10;
+    dContact contacts[10]; //delete ?
+    for( int i = 0; i < 10; ++i )
+    {
+        contacts[i].surface.mode = dContactBounce | dContactSoftCFM;
+        contacts[i].surface.mu = dInfinity;
+        contacts[i].surface.mu2 = 0;
+        contacts[i].surface.bounce = 0.8;
+        contacts[i].surface.bounce_vel = 0.1f;
+        contacts[i].surface.soft_cfm = 0.01f;
+    }
+    int num_contacts = 0;
+    num_contacts = dCollide( id1, id2, (unsigned int)max_contacts, &contacts[0].geom, sizeof(dContact) );
+    for( int i = 0; i < num_contacts; ++i )
+    {
+        dJointID c = dJointCreateContact( ((PhysicsEngine*)_this)->worldId, ((PhysicsEngine*)_this)->contactJointGroup, &contacts[i] );
+        dJointAttach( c, b1, b2 );
+    }
+}
+
+#endif
diff --git a/ogreRenderer/PhysicsEngine.h b/ogreRenderer/PhysicsEngine.h
new file mode 100644
index 0000000..b308c4d
--- /dev/null
+++ b/ogreRenderer/PhysicsEngine.h
@@ -0,0 +1,81 @@
+#ifndef STU_PHYSICS_ENGINE_H
+#define STU_PHYSICS_ENGINE_H
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include <ode/ode.h>
+
+#include "CommonAspect.h"
+#include "Utility.h"
+
+using namespace std;
+
+/*
+ * callback for ODE. friend of PhysicsEngine. _this is meant to be 
+ * a this pointer at the PhysicsEngine object currently using the callback.
+ */
+void nearCollisionCallback( void* _this, dGeomID id1, dGeomID id2 );
+
+class PhysicsEngine : public CommonAspect
+{
+public:
+    PhysicsEngine();
+    virtual ~PhysicsEngine() { dWorldDestroy( this->worldId ); }
+    /**
+     * Add an dynamic item to the engine. A dymanic item 
+     * will move, and have it's position updated.
+     * @param name the id of the item in the engine
+     * @param pos the center of the objects bounding sphere (vector of size 3)
+     * @param radius the radius of the objects bounding sphere
+     */
+    bool addItem( const string& name, const vector<double>& pos, double radius );
+    bool addItem( const string& name, const vector<double>& pos, double edgex, double edgey, double edgez );
+
+    /**
+     * Add a static item to the engine. A static item
+     * is an immovable part of the environment (like the ground).
+     * @param name the id of the item in the engine
+     * @param pos the position of the item (the center of the box, not the corner)
+     * @param edgex the edge defining the bounding box of the static item 
+     * @param edgey ibid
+     * @param edgez ibid
+     */
+    bool addStaticItem( const string& name, const vector<double>& pos, double edgex, double edgey, double edgez );
+    bool addStaticItem( const string& name, const vector<double>& pos, double radius );
+
+    bool removeItem( const string& name );
+
+    bool setGravity( double x, double y, double z );
+    bool setPosition( const string& name, const vector<double>& position );
+    bool setPosition( const string& name, double x, double y, double z );
+    bool setMass( const string& name, double mass );
+    bool setLinearVelocity( const string& name, const vector<double>& velocity );
+    /*
+     * Returns the position of an object (can be dynamic or static)
+     * @param name the name of the object
+     * @param pos the position of the object. 
+     *        The position is appended to the end of the vector.
+     */
+    bool getPosition( const string& name, vector<double>& pos );
+    bool getGravity( vector<double>& grav );
+
+    bool doPhysics();
+    /*
+     * callback for ODE. friend of PhysicsEngine. _this is assumed to be 
+     * a this pointer at the PhysicsEngine object currently using the callback.
+     * Hmm. you can have some pointer overflow fun with this.
+     */
+    friend void nearCollisionCallback( void* _this, dGeomID id1, dGeomID id2 );
+
+private:
+    map<string,dBodyID> bodies;
+    //Pretty much these are stored just so we can remove them later if we want
+    map<string,dGeomID> geometries; 
+    dWorldID worldId;
+    dSpaceID spaceId;
+    dJointGroupID contactJointGroup;
+};
+
+#endif
diff --git a/ogreRenderer/StaticWorldObject.cc b/ogreRenderer/StaticWorldObject.cc
new file mode 100644
index 0000000..52c5cf1
--- /dev/null
+++ b/ogreRenderer/StaticWorldObject.cc
@@ -0,0 +1,28 @@
+#ifndef STATIC_WORLD_OBJECT_CC_STU
+#define STATIC_WORLD_OBJECT_CC_STU
+
+#include "StaticWorldObject.h"
+
+bool StaticWorldObject::create( const string& resourceName )
+{
+    this->logger.print( "Notify: entered StaticWorldObject::create ", this->doNotify );
+    this->graphics = true;
+    this->resourceName = resourceName;
+    Entity* ent = this->sceneManager->createEntity( this->name, resourceName );
+    this->sceneNode = this->sceneManager->getRootSceneNode()->createChildSceneNode( this->name + "Node" );
+    this->sceneNode->attachObject( ent );
+    Vector3 pos = this->sceneNode->getPosition();
+    AxisAlignedBox box = this->sceneNode->getAttachedObject( this->name )->getBoundingBox();
+    Vector3 flb = box.getCorner( AxisAlignedBox::FAR_LEFT_BOTTOM );
+    Vector3 frb = box.getCorner( AxisAlignedBox::FAR_RIGHT_BOTTOM );
+    Vector3 nlb = box.getCorner( AxisAlignedBox::NEAR_LEFT_BOTTOM );
+    Vector3 nlt = box.getCorner( AxisAlignedBox::NEAR_LEFT_TOP );
+    double legx = ( flb - frb ).length();
+    double legy = ( nlt - nlb ).length();
+    double legz = ( nlb - flb ).length();
+    this->physicsEngine->addStaticItem( this->name, Utility::toVector( pos ), legx, legy, legz );
+    return true;
+
+}
+
+#endif
diff --git a/ogreRenderer/StaticWorldObject.h b/ogreRenderer/StaticWorldObject.h
new file mode 100644
index 0000000..cb12cb7
--- /dev/null
+++ b/ogreRenderer/StaticWorldObject.h
@@ -0,0 +1,36 @@
+#ifndef STATIC_WORLD_STU_H
+#define STATIC_WORLD_STU_H
+
+#include <string>
+#include <vector>
+#include <iostream>
+#include <map>
+
+#include "Ogre.h"
+#include "OgreException.h"
+
+#include "Utility.h"
+#include "CommonAspect.h"
+#include "PhysicsEngine.h"
+#include "WorldObject.h"
+
+using namespace std;
+using namespace Ogre;
+
+#define setBackgroundColor setBackgroundColour
+#define ColorValue ColourValue
+#define initialize initialise
+#define initializeAllResourceGroups initialiseAllResourceGroups
+#define setDiffuseColor setDiffuseColour
+#define setSpecularColor setSpecularColour
+
+class StaticWorldObject : public WorldObject
+{
+  public:
+    StaticWorldObject( const string& name, SceneManager* sceneManager, PhysicsEngine* physicsEngine ) : 
+                       WorldObject( name, sceneManager, physicsEngine ){}
+    virtual ~StaticWorldObject() {};
+    virtual bool create( const string& resourceName );
+};
+
+#endif 
diff --git a/ogreRenderer/WorldObject.cc b/ogreRenderer/WorldObject.cc
new file mode 100644
index 0000000..e08e4ed
--- /dev/null
+++ b/ogreRenderer/WorldObject.cc
@@ -0,0 +1,134 @@
+#ifndef WORLD_OBJECT_STU_CC
+#define WORLD_OBJECT_STU_CC
+
+#include "WorldObject.h"
+
+WorldObject::WorldObject( const string& name, SceneManager* sceneManager, PhysicsEngine* physicsEngine )
+{
+    this->name = name; 
+    this->physicsEngine = physicsEngine;
+    this->sceneManager = sceneManager;
+    this->physics = this->graphics = true;
+    this->sceneNode = NULL;
+    this->resourceName = "";
+}
+
+bool WorldObject::create( const string& resourceName ) 
+{ 
+    this->logger.print( "Notify: entered WorldObject::create ", this->doNotify );
+    this->graphics = true;
+    this->resourceName = resourceName;
+    Entity* ent = this->sceneManager->createEntity( this->name, resourceName );
+    this->sceneNode = this->sceneManager->getRootSceneNode()->createChildSceneNode( this->name + "Node" );
+    this->sceneNode->attachObject( ent );
+    double radius = this->sceneNode->getAttachedObject( this->name )->getBoundingRadius(); 
+    this->sceneNode->setPosition( 0, 0, 0 );
+    vector<double> pos;
+    pos.push_back( 0 );
+    pos.push_back( 0 );
+    pos.push_back( 0 );
+    this->physicsEngine->addItem( this->name, pos, radius );
+    return true;
+}
+
+//Developer Node: be sure to update both the physics & the graphical object.
+bool WorldObject::setPosition( const vector<double>& pos )
+{
+    if( pos.size() < 3 )
+    {
+        this->logger.print( "Warning: WorldObject::setPostion, passed a position with less than 3 coordinates" );
+        return false;
+    }
+    bool ret = this->physicsEngine->setPosition( this->name, pos );
+    if( ret )
+    {
+        this->sceneNode->setPosition( pos[0], pos[1], pos[2] );
+    }
+    return ret;
+}
+
+bool WorldObject::setLinearVelocity( const vector<double>& velocity )
+{
+    logger.print( "Notify: entered WorldObject::setLinearVelocity()", this->doNotify );
+    return this->physicsEngine->setLinearVelocity( this->name, velocity ); 
+}
+
+bool WorldObject::setMass( double mass )
+{
+    logger.print( "Notify: entered WorldObject::setMass()", this->doNotify );
+    return this->physicsEngine->setMass( this->name, mass );
+}
+
+bool WorldObject::update()
+{
+    logger.print( "Notify: entered WorldObject::update()", this->doNotify );
+    if( !this->physics || !this->graphics )
+    {
+        return true;
+    }
+
+    vector<double> pos;
+    bool ret = this->physicsEngine->getPosition( this->name, pos );
+    logger.print( "Warning: WorldObject::update() failed to getPostion from physicsEngine", !ret );
+    if( ret )
+    {
+        this->sceneNode->setPosition( pos[0], pos[1], pos[2] );
+    }
+    return ret;
+
+}
+
+bool WorldObject::noPhysics()
+{
+    return !(this->physics = !this->physicsEngine->removeItem( this->name ));
+}
+
+bool WorldObject::restartPhysics()
+{
+    return (this->physics = true);
+}
+
+bool WorldObject::noGraphics()
+{
+    logger.print( "Notify: entered WorldObject::noGraphics()", this->doNotify );
+    this->graphics = false;
+    this->sceneManager->getRootSceneNode()->removeAndDestroyChild( this->name + "Node" );
+    return true;
+}
+
+bool WorldObject::restartGraphics()
+{
+    logger.print( "Notify: entered WorldObject::restartGraphics()", this->doNotify );
+    if( this->graphics )
+    {
+        return true;
+    }
+    else
+    {
+        return (this->graphics = this->create( this->resourceName ) );
+    }
+}
+
+SceneNode* WorldObject::getSceneNode()
+{
+    return this->sceneNode;
+}
+
+bool WorldObject::getName( string& name )
+{
+    name = this->name;
+    return true;
+}
+
+bool WorldObject::getPosition( vector<double>& pos )
+{
+    this->logger.print( "Notify: entered WorldObject::getPosition", this->doNotify );
+    bool ret = this->physicsEngine->getPosition( this->name, pos );
+    if( ret )
+    {
+        this->sceneNode->setPosition( pos[0], pos[1], pos[2] );
+    }
+    return ret;
+}
+
+#endif
diff --git a/ogreRenderer/WorldObject.h b/ogreRenderer/WorldObject.h
new file mode 100644
index 0000000..7d0cb09
--- /dev/null
+++ b/ogreRenderer/WorldObject.h
@@ -0,0 +1,133 @@
+#ifndef WORLD_OBJECT_STU_H
+#define WORLD_OBJECT_STU_H
+
+#include <string>
+#include <vector>
+#include <map>
+#include <ostream>
+
+#include "Ogre.h"
+#include "OgreException.h"
+
+#include "Utility.h"
+#include "CommonAspect.h"
+#include "PhysicsEngine.h"
+#include "WorldObject.h"
+
+using namespace std;
+using namespace Ogre;
+
+#define setBackgroundColor setBackgroundColour
+#define ColorValue ColourValue
+#define initialize initialise
+#define initializeAllResourceGroups initialiseAllResourceGroups
+#define setDiffuseColor setDiffuseColour
+#define setSpecularColor setSpecularColour
+
+/*
+ * And object that glues together the physics of an object
+ * with it's geometry. The link between ODE and OGRE. 
+ * However, stepping the physical world should be done elsewhere.
+ * Be sure to call update()!
+ *
+ * Hmm.. we may add some interface to this to determine the bounding box.
+ * Could use inheritance and override create(), but that may be to much of a pita.
+ *
+ * May become first-class object (probably should). i.e. move to own directory
+ * at top of source tree & simple test & make etc.
+ *
+ * Also, may want to add system member into this sooner rather than later.
+ * This would argue for an LSystemRemote class though...
+ */
+class WorldObject : public CommonAspect
+{
+  public:
+    /*
+     * Initialize a world object at 0,0,0
+     * Does not actually create the object in the world. 
+     * @param name The name used to identify this object
+     *             This is not the same as the name of the resource
+     *             used to create thsi object
+     *             Also, the scene node of this object will be named name + "Node".
+     *            (unless this behavior is overidden)
+     * @param root Ogre root object
+     * @param physicsEngine 
+     */
+    WorldObject( const string& name, SceneManager* sceneManager, PhysicsEngine* physicsEngine );
+    virtual ~WorldObject(){};
+    /*
+     * This method is overriden by child objects to 
+     * provide the ability for object to determine
+     * it's own geometry (vs. by loading a resource, as below)
+     * e.g. SphereObject : public WorldObject would use this to make 
+     *                     a sphere.
+     */
+    virtual bool create() { logger.print("Error: WorldObject::create() invalid for this object. Use create( resourceName )" ); return false; }
+    /*
+     * Creates the geometry of the object from a given resource
+     * Returns false if this object should use a create(), and 
+     * this does not apply.
+     * @param resourceName The name of the resource.
+     *        This is given in terms of Ogre resources (e.g. "ninja.mesh")
+     *        This is not the same as the name of this object, which 
+     *        is maintained separately
+     */
+    virtual bool create( const string& resourceName ); 
+    /*
+     * Set the position of the object.
+     * Use with care, as constantly resetting the position of the object
+     * may mess with the physics.
+     */
+    virtual bool setPosition( const vector<double>& pos );
+    virtual bool setLinearVelocity( const vector<double>& velocity );
+    virtual bool setMass( double mass );
+    /** saved for later.
+     *  physcis engine interface doesn't handle this yet.
+     */
+    virtual bool addForce() { logger.print("Error: WorldObject::addForce not implemented"); return false; }
+    /*
+     * syncs the graphical object to any changes in the physical object.
+     * (e.g., updates the position of the graphical object in response to
+     * any physics that occurred).
+     * call this every frame.
+     */
+    virtual bool update();
+    /*
+     * Removes the object from the physical world but does not destroy
+     * any other state. Useful for "storing" or "ghosting" them. 
+     * calling create() after this call will add the physics state back in.
+     */
+    virtual bool noPhysics();
+    virtual bool restartPhysics();
+    /*
+     * Inverse of noPhyiscs. Removes the graphical state from the world,
+     * but continues to track the physics.
+     * calling create() after this call will add the physics state back in.
+     */
+    virtual bool noGraphics();
+    virtual bool restartGraphics();
+    /*
+     * Returns the sceneNode for this object.
+     * Note that the name of this node will be this->name + "Node"
+     * (unless overidden by child types)
+     */
+    virtual SceneNode* getSceneNode();
+    virtual bool getName( string& name );
+    /*
+     * Gets the position of the object
+     * Note that this will reset the position of the graphical
+     * object to that of the physical object.
+     * @param pos the position of the object.
+     */
+    virtual bool getPosition( vector<double>& pos );
+  protected:
+    PhysicsEngine* physicsEngine;
+    SceneNode* sceneNode;
+    SceneManager* sceneManager;
+    string name; 
+    string resourceName;
+    bool graphics; 
+    bool physics;
+};
+
+#endif
diff --git a/ogreRenderer/testStructEnum.cc b/ogreRenderer/testStructEnum.cc
new file mode 100644
index 0000000..330e052
--- /dev/null
+++ b/ogreRenderer/testStructEnum.cc
@@ -0,0 +1,16 @@
+#include <iostream>
+
+using namespace std;
+
+struct testStruct
+{
+    enum testEnum
+    {
+        FRED = 0, JOE = 1
+    };
+};
+
+int main()
+{
+    testStruct test;
+}
diff --git a/physicsEngine/Makefile b/physicsEngine/Makefile
deleted file mode 100644
index 103676c..0000000
--- a/physicsEngine/Makefile
+++ /dev/null
@@ -1,23 +0,0 @@
-include ../GlobalMakeSettings.mk
-
-TEST=testPhysicsEngine
-TEST_CC=testPhysicsEngine.cc
-OBJ=PhysicsEngine.o
-OBJ_CC=PhysicsEngine.cc
-#CCFLAGS += 
-
-all:$(TEST_DEPENDS) $(TEST)
-
-TEST_DEPENDS=$(LOGGER) $(COMMONASPECT) $(Ode) $(OBJ)
-
-$(TEST):$(TEST_CC) $(TEST_DEPENDS)
-	$(CC) $(CCFLAGS) $(TEST_DEPENDS) $(TEST_CC) -o $(TEST)
-
-include ../GlobalMakeTargets.mk
-
-$(OBJ):$(OBJ_CC)
-	$(CC) $(CCFLAGS) -c $(OBJ_CC) -o $(OBJ)
-
-clean:
-	rm -f $(TEST_DEPENDS)
-	rm -f $(TEST)
diff --git a/physicsEngine/PhysicsEngine.cc b/physicsEngine/PhysicsEngine.cc
deleted file mode 100644
index f332458..0000000
--- a/physicsEngine/PhysicsEngine.cc
+++ /dev/null
@@ -1,282 +0,0 @@
-#ifndef STU_PHYSICS_ENGINE_CC
-#define STU_PHYSICS_ENGINE_CC
-
-#include "PhysicsEngine.h"
-
-PhysicsEngine::PhysicsEngine()
-{
-    this->worldId = dWorldCreate();
-    this->spaceId = dHashSpaceCreate( 0 );
-    this->contactJointGroup = dJointGroupCreate( 0 );
-    dWorldSetGravity( this->worldId, 0, 0, 0 );
-}
-
-bool PhysicsEngine::addItem( const string& name, const vector<double>& pos, double radius )
-{
-    logger.print( "Notify: entered Physics::addItem", this->doNotify );
-    if( bodies.find( name ) != bodies.end() )
-    {
-        //logger.print( "Warning: in PhysicsEngine::addItem attempted to add a body to the physics engine with a duplicate name of: " + name );
-        return false;
-    }
-
-    if( pos.size() < 3 )
-    {
-        logger.print( "Warning: in PhysicsEngine::addItem, passed a position vector with a size < 3" );
-        return false;
-    }
-
-    dGeomID geometry = dCreateSphere( this->spaceId, radius );
-    dBodyID body = dBodyCreate(this->worldId);
-    dGeomSetBody( geometry, body );
-    dBodySetPosition( body, pos[0], pos[1], pos[2] );
-    bodies[name] = body;
-    return true;
-}
-
-bool PhysicsEngine::addItem( const string& name, const vector<double>& pos, double edgex, double edgey, double edgez )
-{
-    logger.print( "Notify: entered Physics::addStaticItem", this->doNotify );
-    if( bodies.find( name ) != bodies.end() )
-    {
-        logger.print( "Warning: in PhysicsEngine::addStaticItem attempted to add a body to the physics engine with a duplicate name of: " + name );
-        return false;
-    }
-
-    if( pos.size() < 3 )
-    {
-        logger.print( "Warning: in PhysicsEngine::addStaticItem, passed a position vector with a size < 3" );
-        return false;
-    }
-    dGeomID geometry = dCreateBox( this->spaceId, edgex, edgey, edgez );
-    dBodyID body = dBodyCreate( this->worldId );
-    dGeomSetBody( geometry, body ); //0 means static body (no rigid body associated with it)
-    dBodySetPosition( body, pos[0], pos[1], pos[2] );
-    this->bodies[name] = body;
-    return true;
-}
-
-
-bool PhysicsEngine::addStaticItem( const string& name, const vector<double>& pos, double edgex, double edgey, double edgez )
-{
-    logger.print( "Notify: entered Physics::addStaticItem", this->doNotify );
-    if( bodies.find( name ) != bodies.end() )
-    {
-        logger.print( "Warning: in PhysicsEngine::addStaticItem attempted to add a body to the physics engine with a duplicate name of: " + name );
-        return false;
-    }
-
-    if( pos.size() < 3 )
-    {
-        logger.print( "Warning: in PhysicsEngine::addStaticItem, passed a position vector with a size < 3" );
-        return false;
-    }
-    dGeomID geometry = dCreateBox( this->spaceId, edgex, edgey, edgez );
-    dGeomSetBody( geometry, 0 ); //0 means static body (no rigid body associated with it)
-    dGeomSetPosition( geometry, pos[0], pos[1], pos[2] );
-    this->geometries[name] = geometry;
-    return true;
-}
-
-bool PhysicsEngine::addStaticItem( const string& name, const vector<double>& pos, double radius )
-{
-    logger.print( "Notify: entered Physics::addStaticItem", this->doNotify );
-    if( bodies.find( name ) != bodies.end() )
-    {
-        logger.print( "Warning: in PhysicsEngine::addStaticItem attempted to add a body to the physics engine with a duplicate name of: " + name );
-        return false;
-    }
-
-    if( pos.size() < 3 )
-    {
-        logger.print( "Warning: in PhysicsEngine::addStaticItem, passed a position vector with a size < 3" );
-        return false;
-    }
-    dGeomID geometry = dCreateSphere( this->spaceId, radius );
-    dGeomSetBody( geometry, 0 ); //0 means static body (no rigid body associated with it)
-    dGeomSetPosition( geometry, pos[0], pos[1], pos[2] );
-    this->geometries[name] = geometry;
-    return true;
-}
-
-bool PhysicsEngine::removeItem( const string& name )
-{
-    if( bodies.find( name ) == bodies.end() and geometries.find( name ) == geometries.end() )
-    {
-        logger.print( "Notify: in PhysicsEngine, attempt to remove an item " + name + " that does not exist", this->doNotify );
-        return false;
-    }
-
-    if( bodies.find( name ) != bodies.end() )
-    {
-        dBodyDestroy( this->bodies[name] );
-        this->bodies.erase(name);
-    }
-    if( geometries.find( name ) != geometries.end() )
-    {
-        dGeomDestroy( this->geometries[name] );
-        this->geometries.erase(name);
-    }
-    return true;
-}
-
-bool PhysicsEngine::setGravity( double x, double y, double z )
-{
-    dWorldSetGravity( this->worldId, x, y, z );
-    return true;
-}
-
-bool PhysicsEngine::setPosition( const string& name, const vector<double>& position )
-{
-    logger.print( "Notify: entered Physics::setPosition", this->doNotify );
-    if( bodies.find( name ) == bodies.end() )
-    {
-        logger.print( "Notify: in PhysicsEngine::setPosition attempted to set the position of a body that does not exist, the name tried was: " + name, this->doNotify );
-        return false;
-    }
-
-    if( position.size() < 3 )
-    {
-        logger.print( "Warning: Oop! we only support objects in a 3-manifold\n" +
-                      string("Warning: (Your position vector in PhysicsEngine::updateItemPosition had a size < 3)") );
-    }
-
-    dBodySetPosition( bodies[name], position[0], position[1], position[2] );
-    return true;
-}
-
-bool PhysicsEngine::setPosition( const string& name, double x, double y, double z )
-{
-    logger.print( "Notify: entered Physics::setPosition(x,y,z)", this->doNotify );
-    if( bodies.find( name ) == bodies.end() )
-    {
-        logger.print( "Notify: in PhysicsEngine::setPosition(x,y,z) attempted to set the position of a body that does not exist, the name tried was: " + name, this->doNotify );
-        return false;
-    }
-
-    dBodySetPosition( bodies[name], x, y, z );
-    return true;
-}
-
-bool PhysicsEngine::setMass( const string& name, double mass )
-{
-    logger.print( "Notify: entered Physics::setMass", this->doNotify );
-    if( bodies.find( name ) == bodies.end() )
-    {
-        logger.print( "Notify: in PhysicsEngine::setMass, attempted to set the mass of a body that does not exist, the name tried was: " + name, this->doNotify );
-        return false;
-    }
-
-    dMass dmass;
-    dMassSetZero( &dmass );
-    dmass.mass = mass;
-    dBodySetMass( bodies[name], &dmass );
-    return true;
-
-}
-
-bool PhysicsEngine::setLinearVelocity( const string& name, const vector<double>& vel )
-{
-    logger.print( "Notify: entered Physics::setLinearVelocity", this->doNotify );
-    if( bodies.find( name ) == bodies.end() )
-    {
-        logger.print( "Notify: in PhysicsEngine::setLinearVelocity attempted to set the linear velocity of a body that does not exist, the name tried was: " + name, this->doNotify );
-        return false;
-    }
-
-    if( vel.size() < 3 )
-    {
-        logger.print( "Warning: in PhysicsEngine::setLinearVelocity, passed a velocity vector with a size < 3" );
-        return false;
-    }
-
-    dBodySetLinearVel( bodies[name], vel[0], vel[1], vel[2] );
-    return true;
-
-}
-
-bool PhysicsEngine::getPosition( const string& name, vector<double>& pos )
-{
-    logger.print( "Notify: entered Physics::getPosition", this->doNotify );
-    if( this->bodies.find( name ) == this->bodies.end() && 
-        this->geometries.find( name ) == this->geometries.end()  )
-    {
-        //this happens often enough that we don't bother with warning
-        logger.print( "Notify: in PhysicsEngine::getPosition(x,y,z) attempted to get the position of a body/geom that does not exist, the name tried was: " + name, this->doNotify );
-        return false;
-    }
-
-    if( this->bodies.find( name ) != this->bodies.end() )
-    {
-        const dReal* phy_pos = dBodyGetPosition( this->bodies[name] );
-        pos.push_back( phy_pos[0] );
-        pos.push_back( phy_pos[1] );
-        pos.push_back( phy_pos[2] );
-    }
-    else
-    {
-        const dReal* phy_pos = dGeomGetPosition( this->geometries[name] );
-        pos.push_back( phy_pos[0] );
-        pos.push_back( phy_pos[1] );
-        pos.push_back( phy_pos[2] );
-    }
-    return true;
-}
-
-
-bool PhysicsEngine::getGravity( vector<double>& grav )
-{
-    dVector3 odeGrav;
-    dWorldGetGravity( this->worldId, odeGrav );
-    grav.push_back( odeGrav[0] );
-    grav.push_back( odeGrav[1] );
-    grav.push_back( odeGrav[2] );
-    return true;
-}
-
-bool PhysicsEngine::doPhysics()
-{
-    dSpaceCollide( this->spaceId, this, &nearCollisionCallback );
-    dWorldQuickStep( this->worldId, 1 );
-    dJointGroupEmpty( this->contactJointGroup );
-    return true;
-}
-
-/*
- * callback for ODE. friend of PhysicsEngine. _this is meant to be 
- * a this pointer at the PhysicsEngine object currently using the callback.
- */
-void nearCollisionCallback( void* _this, dGeomID id1, dGeomID id2 )
-{
-    dBodyID b1 = dGeomGetBody( id1 );
-    dBodyID b2 = dGeomGetBody( id2 );
-
-    //if( b1 && b2 && dAreConnectedExcluding( b1, b2, dJointTypeContact ) )
-    //    return;
-
-    //TODO: ...
-    //er, technically the second argument to dCollide is a "flag" whose lower 
-    //16 bits is an integer with the max number of contacts. And the upper 16 bits
-    //are "Reserved for future use". Yup, that's right.
-    //Heck, these guys should write an RFC
-    short max_contacts = 10;
-    dContact contacts[10]; //delete ?
-    for( int i = 0; i < 10; ++i )
-    {
-        contacts[i].surface.mode = dContactBounce | dContactSoftCFM;
-        contacts[i].surface.mu = dInfinity;
-        contacts[i].surface.mu2 = 0;
-        contacts[i].surface.bounce = 0.8;
-        contacts[i].surface.bounce_vel = 0.1f;
-        contacts[i].surface.soft_cfm = 0.01f;
-    }
-    int num_contacts = 0;
-    num_contacts = dCollide( id1, id2, (unsigned int)max_contacts, &contacts[0].geom, sizeof(dContact) );
-    for( int i = 0; i < num_contacts; ++i )
-    {
-        dJointID c = dJointCreateContact( ((PhysicsEngine*)_this)->worldId, ((PhysicsEngine*)_this)->contactJointGroup, &contacts[i] );
-        dJointAttach( c, b1, b2 );
-    }
-}
-
-#endif
diff --git a/physicsEngine/PhysicsEngine.h b/physicsEngine/PhysicsEngine.h
deleted file mode 100644
index b308c4d..0000000
--- a/physicsEngine/PhysicsEngine.h
+++ /dev/null
@@ -1,81 +0,0 @@
-#ifndef STU_PHYSICS_ENGINE_H
-#define STU_PHYSICS_ENGINE_H
-
-#include <map>
-#include <string>
-#include <vector>
-
-#include <ode/ode.h>
-
-#include "CommonAspect.h"
-#include "Utility.h"
-
-using namespace std;
-
-/*
- * callback for ODE. friend of PhysicsEngine. _this is meant to be 
- * a this pointer at the PhysicsEngine object currently using the callback.
- */
-void nearCollisionCallback( void* _this, dGeomID id1, dGeomID id2 );
-
-class PhysicsEngine : public CommonAspect
-{
-public:
-    PhysicsEngine();
-    virtual ~PhysicsEngine() { dWorldDestroy( this->worldId ); }
-    /**
-     * Add an dynamic item to the engine. A dymanic item 
-     * will move, and have it's position updated.
-     * @param name the id of the item in the engine
-     * @param pos the center of the objects bounding sphere (vector of size 3)
-     * @param radius the radius of the objects bounding sphere
-     */
-    bool addItem( const string& name, const vector<double>& pos, double radius );
-    bool addItem( const string& name, const vector<double>& pos, double edgex, double edgey, double edgez );
-
-    /**
-     * Add a static item to the engine. A static item
-     * is an immovable part of the environment (like the ground).
-     * @param name the id of the item in the engine
-     * @param pos the position of the item (the center of the box, not the corner)
-     * @param edgex the edge defining the bounding box of the static item 
-     * @param edgey ibid
-     * @param edgez ibid
-     */
-    bool addStaticItem( const string& name, const vector<double>& pos, double edgex, double edgey, double edgez );
-    bool addStaticItem( const string& name, const vector<double>& pos, double radius );
-
-    bool removeItem( const string& name );
-
-    bool setGravity( double x, double y, double z );
-    bool setPosition( const string& name, const vector<double>& position );
-    bool setPosition( const string& name, double x, double y, double z );
-    bool setMass( const string& name, double mass );
-    bool setLinearVelocity( const string& name, const vector<double>& velocity );
-    /*
-     * Returns the position of an object (can be dynamic or static)
-     * @param name the name of the object
-     * @param pos the position of the object. 
-     *        The position is appended to the end of the vector.
-     */
-    bool getPosition( const string& name, vector<double>& pos );
-    bool getGravity( vector<double>& grav );
-
-    bool doPhysics();
-    /*
-     * callback for ODE. friend of PhysicsEngine. _this is assumed to be 
-     * a this pointer at the PhysicsEngine object currently using the callback.
-     * Hmm. you can have some pointer overflow fun with this.
-     */
-    friend void nearCollisionCallback( void* _this, dGeomID id1, dGeomID id2 );
-
-private:
-    map<string,dBodyID> bodies;
-    //Pretty much these are stored just so we can remove them later if we want
-    map<string,dGeomID> geometries; 
-    dWorldID worldId;
-    dSpaceID spaceId;
-    dJointGroupID contactJointGroup;
-};
-
-#endif
diff --git a/physicsEngine/testPhysicsEngine.cc b/physicsEngine/testPhysicsEngine.cc
deleted file mode 100644
index a262bf6..0000000
--- a/physicsEngine/testPhysicsEngine.cc
+++ /dev/null
@@ -1,45 +0,0 @@
-#include <iostream>
-#include <vector>
-#include <map>
-#include <string>
-
-#include "PhysicsEngine.h"
-#include "Utility.h"
-
-using namespace std;
-
-int main()
-{
-    PhysicsEngine pe;
-    vector<double> grav;
-    pe.getGravity( grav );
-    cout << "gravity: " << Utility::vectorToString( grav ) << endl;
-    vector<double> pos = Utility::makeVector( 0.0, 0.0, 0.0 );
-    vector<double> pos2 = Utility::makeVector( 0.0, 10.0, 0.0 );
-    vector<double> newpos1;
-    vector<double> newpos2;
-    pe.addItem( "test1", pos, 5 );
-    pe.addItem( "test2", pos2, 2 );
-    pe.setMass( "test1", 5 );
-    pe.setMass( "test2", 5 );
-
-
-    cout << "before: " << endl;
-    pe.getPosition( "test1", newpos1 );
-    pe.getPosition( "test2", newpos2 );
-    cout << "pos 1: " << Utility::vectorToString( newpos1 ) << endl;
-    cout << "pos 2: " << Utility::vectorToString( newpos2 ) << endl;
-    vector<double> vel = Utility::makeVector( 0.0, -3.0, 0.0 );
-    pe.setLinearVelocity( "test2", vel ); 
-    for( int i = 0; i < 5; ++i )
-        pe.doPhysics();
-
-    newpos1.clear();
-    newpos2.clear();
-    cout << "set vel on 2 (down): " << Utility::vectorToString( vel ) << endl;
-    pe.getPosition( "test1", newpos1 );
-    pe.getPosition( "test2", newpos2 );
-    cout << "pos 1 (should be negative): " << Utility::vectorToString( newpos1 ) << endl;
-    cout << "pos 2 (should be positive): " << Utility::vectorToString( newpos2 ) << endl;
-
-}
diff --git a/utilityFiles/Utility.h b/utilityFiles/Utility.h
index f1dafc3..4fd5e39 100644
--- a/utilityFiles/Utility.h
+++ b/utilityFiles/Utility.h
@@ -325,14 +325,6 @@ namespace Utility
         return temp;
     }
 
-    /** lazy version **/
-    template <class T>
-    static inline string vectorToString( const vector<T>& vec, string delim = ",", bool doDelim = true )
-    {
-        bool success;
-        return Utility::vectorToString( vec, success, delim, doDelim );
-    }
-
     /**
     * Constructs a string representation of a hash (a map keyed with strings)
     * @param hash The hash to assemble
diff --git a/worldObject/Makefile b/worldObject/Makefile
deleted file mode 100644
index fc666e2..0000000
--- a/worldObject/Makefile
+++ /dev/null
@@ -1,25 +0,0 @@
-include ../GlobalMakeSettings.mk
-
-TEST=testWorldObject
-TEST_CC=testWorldObject.cc
-OBJ=WorldObject.o
-OBJ_CC=WorldObject.cc
-#CCFLAGS += 
-all:$(TEST_DEPENDS) $(TEST)
-
-TEST_DEPENDS=$(LOGGER) $(COMMONASPECT) $(PhysicsEngine) $(Ogre) $(Ode) $(OBJ) 
-#don't keep -lode from $(Ode)
-TEST_CLEAN_DEPENDS=$(LOGGER) $(COMMONASPECT) $(PhysicsEngine) $(Ogre) $(ODE) $(OBJ) 
-
-
-$(TEST):$(TEST_CC) $(TEST_DEPENDS)
-	$(CC) $(CCFLAGS) $(TEST_DEPENDS) $(TEST_CC) -o $(TEST)
-
-include ../GlobalMakeTargets.mk
-
-$(OBJ):$(OBJ_CC)
-	$(CC) $(CCFLAGS) -c $(OBJ_CC) -o $(OBJ)
-
-clean:
-	rm -f $(TEST_CLEAN_DEPENDS)
-	rm -f $(TEST)
diff --git a/worldObject/WorldObject.cc b/worldObject/WorldObject.cc
deleted file mode 100644
index e08e4ed..0000000
--- a/worldObject/WorldObject.cc
+++ /dev/null
@@ -1,134 +0,0 @@
-#ifndef WORLD_OBJECT_STU_CC
-#define WORLD_OBJECT_STU_CC
-
-#include "WorldObject.h"
-
-WorldObject::WorldObject( const string& name, SceneManager* sceneManager, PhysicsEngine* physicsEngine )
-{
-    this->name = name; 
-    this->physicsEngine = physicsEngine;
-    this->sceneManager = sceneManager;
-    this->physics = this->graphics = true;
-    this->sceneNode = NULL;
-    this->resourceName = "";
-}
-
-bool WorldObject::create( const string& resourceName ) 
-{ 
-    this->logger.print( "Notify: entered WorldObject::create ", this->doNotify );
-    this->graphics = true;
-    this->resourceName = resourceName;
-    Entity* ent = this->sceneManager->createEntity( this->name, resourceName );
-    this->sceneNode = this->sceneManager->getRootSceneNode()->createChildSceneNode( this->name + "Node" );
-    this->sceneNode->attachObject( ent );
-    double radius = this->sceneNode->getAttachedObject( this->name )->getBoundingRadius(); 
-    this->sceneNode->setPosition( 0, 0, 0 );
-    vector<double> pos;
-    pos.push_back( 0 );
-    pos.push_back( 0 );
-    pos.push_back( 0 );
-    this->physicsEngine->addItem( this->name, pos, radius );
-    return true;
-}
-
-//Developer Node: be sure to update both the physics & the graphical object.
-bool WorldObject::setPosition( const vector<double>& pos )
-{
-    if( pos.size() < 3 )
-    {
-        this->logger.print( "Warning: WorldObject::setPostion, passed a position with less than 3 coordinates" );
-        return false;
-    }
-    bool ret = this->physicsEngine->setPosition( this->name, pos );
-    if( ret )
-    {
-        this->sceneNode->setPosition( pos[0], pos[1], pos[2] );
-    }
-    return ret;
-}
-
-bool WorldObject::setLinearVelocity( const vector<double>& velocity )
-{
-    logger.print( "Notify: entered WorldObject::setLinearVelocity()", this->doNotify );
-    return this->physicsEngine->setLinearVelocity( this->name, velocity ); 
-}
-
-bool WorldObject::setMass( double mass )
-{
-    logger.print( "Notify: entered WorldObject::setMass()", this->doNotify );
-    return this->physicsEngine->setMass( this->name, mass );
-}
-
-bool WorldObject::update()
-{
-    logger.print( "Notify: entered WorldObject::update()", this->doNotify );
-    if( !this->physics || !this->graphics )
-    {
-        return true;
-    }
-
-    vector<double> pos;
-    bool ret = this->physicsEngine->getPosition( this->name, pos );
-    logger.print( "Warning: WorldObject::update() failed to getPostion from physicsEngine", !ret );
-    if( ret )
-    {
-        this->sceneNode->setPosition( pos[0], pos[1], pos[2] );
-    }
-    return ret;
-
-}
-
-bool WorldObject::noPhysics()
-{
-    return !(this->physics = !this->physicsEngine->removeItem( this->name ));
-}
-
-bool WorldObject::restartPhysics()
-{
-    return (this->physics = true);
-}
-
-bool WorldObject::noGraphics()
-{
-    logger.print( "Notify: entered WorldObject::noGraphics()", this->doNotify );
-    this->graphics = false;
-    this->sceneManager->getRootSceneNode()->removeAndDestroyChild( this->name + "Node" );
-    return true;
-}
-
-bool WorldObject::restartGraphics()
-{
-    logger.print( "Notify: entered WorldObject::restartGraphics()", this->doNotify );
-    if( this->graphics )
-    {
-        return true;
-    }
-    else
-    {
-        return (this->graphics = this->create( this->resourceName ) );
-    }
-}
-
-SceneNode* WorldObject::getSceneNode()
-{
-    return this->sceneNode;
-}
-
-bool WorldObject::getName( string& name )
-{
-    name = this->name;
-    return true;
-}
-
-bool WorldObject::getPosition( vector<double>& pos )
-{
-    this->logger.print( "Notify: entered WorldObject::getPosition", this->doNotify );
-    bool ret = this->physicsEngine->getPosition( this->name, pos );
-    if( ret )
-    {
-        this->sceneNode->setPosition( pos[0], pos[1], pos[2] );
-    }
-    return ret;
-}
-
-#endif
diff --git a/worldObject/WorldObject.h b/worldObject/WorldObject.h
deleted file mode 100644
index 7d0cb09..0000000
--- a/worldObject/WorldObject.h
+++ /dev/null
@@ -1,133 +0,0 @@
-#ifndef WORLD_OBJECT_STU_H
-#define WORLD_OBJECT_STU_H
-
-#include <string>
-#include <vector>
-#include <map>
-#include <ostream>
-
-#include "Ogre.h"
-#include "OgreException.h"
-
-#include "Utility.h"
-#include "CommonAspect.h"
-#include "PhysicsEngine.h"
-#include "WorldObject.h"
-
-using namespace std;
-using namespace Ogre;
-
-#define setBackgroundColor setBackgroundColour
-#define ColorValue ColourValue
-#define initialize initialise
-#define initializeAllResourceGroups initialiseAllResourceGroups
-#define setDiffuseColor setDiffuseColour
-#define setSpecularColor setSpecularColour
-
-/*
- * And object that glues together the physics of an object
- * with it's geometry. The link between ODE and OGRE. 
- * However, stepping the physical world should be done elsewhere.
- * Be sure to call update()!
- *
- * Hmm.. we may add some interface to this to determine the bounding box.
- * Could use inheritance and override create(), but that may be to much of a pita.
- *
- * May become first-class object (probably should). i.e. move to own directory
- * at top of source tree & simple test & make etc.
- *
- * Also, may want to add system member into this sooner rather than later.
- * This would argue for an LSystemRemote class though...
- */
-class WorldObject : public CommonAspect
-{
-  public:
-    /*
-     * Initialize a world object at 0,0,0
-     * Does not actually create the object in the world. 
-     * @param name The name used to identify this object
-     *             This is not the same as the name of the resource
-     *             used to create thsi object
-     *             Also, the scene node of this object will be named name + "Node".
-     *            (unless this behavior is overidden)
-     * @param root Ogre root object
-     * @param physicsEngine 
-     */
-    WorldObject( const string& name, SceneManager* sceneManager, PhysicsEngine* physicsEngine );
-    virtual ~WorldObject(){};
-    /*
-     * This method is overriden by child objects to 
-     * provide the ability for object to determine
-     * it's own geometry (vs. by loading a resource, as below)
-     * e.g. SphereObject : public WorldObject would use this to make 
-     *                     a sphere.
-     */
-    virtual bool create() { logger.print("Error: WorldObject::create() invalid for this object. Use create( resourceName )" ); return false; }
-    /*
-     * Creates the geometry of the object from a given resource
-     * Returns false if this object should use a create(), and 
-     * this does not apply.
-     * @param resourceName The name of the resource.
-     *        This is given in terms of Ogre resources (e.g. "ninja.mesh")
-     *        This is not the same as the name of this object, which 
-     *        is maintained separately
-     */
-    virtual bool create( const string& resourceName ); 
-    /*
-     * Set the position of the object.
-     * Use with care, as constantly resetting the position of the object
-     * may mess with the physics.
-     */
-    virtual bool setPosition( const vector<double>& pos );
-    virtual bool setLinearVelocity( const vector<double>& velocity );
-    virtual bool setMass( double mass );
-    /** saved for later.
-     *  physcis engine interface doesn't handle this yet.
-     */
-    virtual bool addForce() { logger.print("Error: WorldObject::addForce not implemented"); return false; }
-    /*
-     * syncs the graphical object to any changes in the physical object.
-     * (e.g., updates the position of the graphical object in response to
-     * any physics that occurred).
-     * call this every frame.
-     */
-    virtual bool update();
-    /*
-     * Removes the object from the physical world but does not destroy
-     * any other state. Useful for "storing" or "ghosting" them. 
-     * calling create() after this call will add the physics state back in.
-     */
-    virtual bool noPhysics();
-    virtual bool restartPhysics();
-    /*
-     * Inverse of noPhyiscs. Removes the graphical state from the world,
-     * but continues to track the physics.
-     * calling create() after this call will add the physics state back in.
-     */
-    virtual bool noGraphics();
-    virtual bool restartGraphics();
-    /*
-     * Returns the sceneNode for this object.
-     * Note that the name of this node will be this->name + "Node"
-     * (unless overidden by child types)
-     */
-    virtual SceneNode* getSceneNode();
-    virtual bool getName( string& name );
-    /*
-     * Gets the position of the object
-     * Note that this will reset the position of the graphical
-     * object to that of the physical object.
-     * @param pos the position of the object.
-     */
-    virtual bool getPosition( vector<double>& pos );
-  protected:
-    PhysicsEngine* physicsEngine;
-    SceneNode* sceneNode;
-    SceneManager* sceneManager;
-    string name; 
-    string resourceName;
-    bool graphics; 
-    bool physics;
-};
-
-#endif
diff --git a/worldObject/staticWorldObject/Makefile b/worldObject/staticWorldObject/Makefile
deleted file mode 100644
index a30667d..0000000
--- a/worldObject/staticWorldObject/Makefile
+++ /dev/null
@@ -1,24 +0,0 @@
-include ../../GlobalMakeSettings.mk
-
-TEST=testStaticWorldObject
-TEST_CC=testStaticWorldObject.cc
-OBJ=StaticWorldObject.o
-OBJ_CC=StaticWorldObject.cc
-#CCFLAGS += 
-all:$(TEST_DEPENDS) $(TEST)
-
-TEST_DEPENDS=$(LOGGER) $(COMMONASPECT) $(WorldObject) $(PhysicsEngine) $(Ogre) $(Ode) $(OBJ) 
-TEST_CLEAN_DEPENDS=$(LOGGER) $(COMMONASPECT) $(WorldObject) $(PhysicsEngine) $(Ogre) $(ODE) $(OBJ) 
-
-
-$(TEST):$(TEST_CC) $(TEST_DEPENDS)
-	$(CC) $(CCFLAGS) $(TEST_DEPENDS) $(TEST_CC) -o $(TEST)
-
-include ../../GlobalMakeTargets.mk
-
-$(OBJ):$(OBJ_CC)
-	$(CC) $(CCFLAGS) -c $(OBJ_CC) -o $(OBJ)
-
-clean:
-	rm -f $(TEST_CLEAN_DEPENDS)
-	rm -f $(TEST)
diff --git a/worldObject/staticWorldObject/StaticWorldObject.cc b/worldObject/staticWorldObject/StaticWorldObject.cc
deleted file mode 100644
index 52c5cf1..0000000
--- a/worldObject/staticWorldObject/StaticWorldObject.cc
+++ /dev/null
@@ -1,28 +0,0 @@
-#ifndef STATIC_WORLD_OBJECT_CC_STU
-#define STATIC_WORLD_OBJECT_CC_STU
-
-#include "StaticWorldObject.h"
-
-bool StaticWorldObject::create( const string& resourceName )
-{
-    this->logger.print( "Notify: entered StaticWorldObject::create ", this->doNotify );
-    this->graphics = true;
-    this->resourceName = resourceName;
-    Entity* ent = this->sceneManager->createEntity( this->name, resourceName );
-    this->sceneNode = this->sceneManager->getRootSceneNode()->createChildSceneNode( this->name + "Node" );
-    this->sceneNode->attachObject( ent );
-    Vector3 pos = this->sceneNode->getPosition();
-    AxisAlignedBox box = this->sceneNode->getAttachedObject( this->name )->getBoundingBox();
-    Vector3 flb = box.getCorner( AxisAlignedBox::FAR_LEFT_BOTTOM );
-    Vector3 frb = box.getCorner( AxisAlignedBox::FAR_RIGHT_BOTTOM );
-    Vector3 nlb = box.getCorner( AxisAlignedBox::NEAR_LEFT_BOTTOM );
-    Vector3 nlt = box.getCorner( AxisAlignedBox::NEAR_LEFT_TOP );
-    double legx = ( flb - frb ).length();
-    double legy = ( nlt - nlb ).length();
-    double legz = ( nlb - flb ).length();
-    this->physicsEngine->addStaticItem( this->name, Utility::toVector( pos ), legx, legy, legz );
-    return true;
-
-}
-
-#endif
diff --git a/worldObject/staticWorldObject/StaticWorldObject.h b/worldObject/staticWorldObject/StaticWorldObject.h
deleted file mode 100644
index cb12cb7..0000000
--- a/worldObject/staticWorldObject/StaticWorldObject.h
+++ /dev/null
@@ -1,36 +0,0 @@
-#ifndef STATIC_WORLD_STU_H
-#define STATIC_WORLD_STU_H
-
-#include <string>
-#include <vector>
-#include <iostream>
-#include <map>
-
-#include "Ogre.h"
-#include "OgreException.h"
-
-#include "Utility.h"
-#include "CommonAspect.h"
-#include "PhysicsEngine.h"
-#include "WorldObject.h"
-
-using namespace std;
-using namespace Ogre;
-
-#define setBackgroundColor setBackgroundColour
-#define ColorValue ColourValue
-#define initialize initialise
-#define initializeAllResourceGroups initialiseAllResourceGroups
-#define setDiffuseColor setDiffuseColour
-#define setSpecularColor setSpecularColour
-
-class StaticWorldObject : public WorldObject
-{
-  public:
-    StaticWorldObject( const string& name, SceneManager* sceneManager, PhysicsEngine* physicsEngine ) : 
-                       WorldObject( name, sceneManager, physicsEngine ){}
-    virtual ~StaticWorldObject() {};
-    virtual bool create( const string& resourceName );
-};
-
-#endif 
diff --git a/worldObject/staticWorldObject/testStaticWorldObject.cc b/worldObject/staticWorldObject/testStaticWorldObject.cc
deleted file mode 100644
index c3aaa6c..0000000
--- a/worldObject/staticWorldObject/testStaticWorldObject.cc
+++ /dev/null
@@ -1,13 +0,0 @@
-#include <iostream>
-#include <vector>
-#include <map>
-#include <string>
-
-#include "StaticWorldObject.h"
-
-using namespace std;
-
-int main()
-{
-    map<string,StaticWorldObject*> objs;
-}
diff --git a/worldObject/testWorldObject.cc b/worldObject/testWorldObject.cc
deleted file mode 100644
index 9b11e9c..0000000
--- a/worldObject/testWorldObject.cc
+++ /dev/null
@@ -1,13 +0,0 @@
-#include <iostream>
-#include <vector>
-#include <map>
-#include <string>
-
-#include "WorldObject.h"
-
-using namespace std;
-
-int main()
-{
-    map<string,WorldObject*> objs;
-}
