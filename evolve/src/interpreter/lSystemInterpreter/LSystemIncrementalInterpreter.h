#ifndef STU_INTERPRETER_INCREMENTAL_H
#define STU_INTERPRETER_INCREMENTAL_H

#define DO_DEBUG true

#include "Interpreter.h"
#include "Matrix.h"
#include "Utility.h"
#include "LSystem.h"
#include "LSystemGenericInterpreter.h"
#include <iostream>
#include <fstream>
#include <boost/lexical_cast.hpp>

using namespace std;
using namespace boost;
using namespace evolve;

namespace evolve
{
    /**
     * Class designed to incrementally interpret an lsystem into a series of points, and allow for it to be updated.
     * This is so we can update it to respond to environmental changes, like physics.
     * Used like so:<br/>
     * <pre>
     *  int = LSystemIncrementalInterpreter( System );
     * start:
     *  int->grow( &index, point ) 
     *  [add point to some other structure (physics?)]
     *  [update other structure, points move around]
     *  loop points:
     *   int->updatePoint( index )
     * goto start 
     * </pre>
     * This class uses the same attributes in the same way as the LSystemGenericInterpreter, with the following caveats:
     * <ul>
     * <li>setElementSize can be used to override the AtomicSize attribute for the distance a specific element is to move</li>
     * <li>elements are interpreted if the first character of the element matches L,R,U,D,S, which means you can have L(stuff), and
     * it will still be interpreted. The idea is we will add suffix modifiers later. Also, higher-level classes can use suffixes for there own purposes.</li>
     * <li>[,], do not follow the above rule</li>
     * </ul>
     * For an overview, and nifty (i.e lame) html diagram of how this works vis a vis attributes and 
     * system->point mapping, see LSystemGenericInterpreter docs.
     */
    class LSystemIncrementalInterpreter : public LSystemGenericInterpreter
    {
    public:
        LSystemIncrementalInterpreter( const System* lSystem );
        virtual ~LSystemIncrementalInterpreter() {};
        //this will just returned the state of the system so far...
        virtual bool getSystem( string& interpretedSystem, System& lSystem, bool printDebug = DO_DEBUG );
        virtual bool getSystem( string& interpretedSystem, string& lSystem, bool printDebug = DO_DEBUG );
        virtual bool getSystem( string& interpretedSystem, bool printDebug = DO_DEBUG );

        virtual bool getCopy( Interpreter*& interpreter, bool printDebug = DO_DEBUG );
       
        //New Methods
        /**
         * Interprets one new element in the L-System.
         * Note that a L-System element does not always generate a new point ("[")
         * If this returns false, the element could not be interpreted, and any index value is invalid.
         * @param newPoint (out). If grown, the new point added to the interpreted system. 
         *                        This vector is cleared of any elements passed in.
         * @param index (out). A unique number associated with this point. (Unique within the context of one
         *                     instance of this interpreter). Note that 0xFFFFFFFE and 0xFFFFFFFF are hard-coded indicies
         *                     used for special elements ("[" and "]"). So it is more than likely you will see these values.
         *                     Don't assume that it just failed to make a new point in that case. CHECK the RETURN value to know.
         */
        virtual bool grow( vector<double>& newPoint, unsigned int& index );
        /**
         * prev returns the last point created <i>for the current branch</i>.
         * Note this means if you have p1, [ p2, p3, p4 ], it will return p1
         * Be careful! Note that the semantics of this mean if you call prev() when it's like this:
         * p1, [ p2, p3, p4  (and cache p4 for later use). 
         * And then you run grow until it returns a new point: p1, [ p2, p3, p4 ], p5.
         * You will have run grow twice, and your cached prev() will be <i>two</i> elements behind.
         * So be sure you update your prev before every grow() (if you're just trying to store the last point).
         *
         * @param prev the previous point. This vector is cleared of any elements passed in.
         * @param index A unique number associated with this point. Same as that returned by the grow() which yielded this point.
         */
        virtual bool prev( vector<double>& prev, unsigned int& index );
        /**
         * Retrieve the system element associated with a given point.
         * E.g. if point (0,0,0) was generated by the system element "S", and had an index of 42,
         * passing 42 to this method will yield the element "S".
         * @param element return argument. The system element associated with this index.
         * @param index the index of the point you wish to retrieve the corresponding element for.
         */
        virtual bool getElement( string& element, unsigned int index );
        /**
         * Set a specific distance to step when encountering a given element.
         * Allows for hetergenous distance steps in the interpretation of the system.
         * @param element The element that maps to this distance step
         * @param size The "size" of the element/the distance to step
         */
        virtual bool setElementSize( const string& element, double size );
        /**
         * Updates a point identified the given index
         * @param index the index of the point
         * @param point the new value for the point
         */
        virtual bool updatePoint( unsigned int index, const vector<double>& point );  
        /**
         * Returns the number of points in the interpreted system
         */
        virtual unsigned int getSize();
        /**
         * Returns a list of points that is the interpreted system
         */
        virtual vector< vector<double> > getPoints();
        /**
         * Returns a point mapped to the given index
         */
        virtual vector<double> getPoint( unsigned int index );
        /**
         * Retrieves the current direction of the interpreter. Useful for knowing which
         * way is "forward" when rendering as system (for aligning graphical elements to the current direction).
         * @param direction [out] returns the current direction of travel for the interpreter
         */
        virtual bool getCurrentDirection( vector<double>& direction );
        /**
         * Take a wild guess ;)
         */
        virtual void printSystem();

    protected:
        System* system;
        //the interpreted location of each element
        vector< vector<double> > points;
        /** point stacks, maintained for the sake of branches **/
        //A stack of for the last point in the parent branch, and the current point
        //stores the index of the point in the points vector, and the value of the point
        //(can't just store pointer to point,because points vector may resize :( )
        vector< pair< unsigned int, vector<double> > > turtlePointStack;
        //maps indices to the element that generated the point they are associated with
        map< unsigned int, string > elements;
        //maps indices to the movement vector of that element
        map< unsigned int, vector<double> > movementVectors;
        //A stack of the current movement axis (the direction any new movement should go in)
        vector< vector<double> > turtleMovementStack;
        //the axis used for up/down rotations. Note this will be the cross product of
        //the movement & the horizontal axis, and will need to get updated whenever we
        //rotate about the horizontal axis.
        vector< vector<double> > turtleVerticalAxisStack;
        //the axis we currently use for left/right rotations. Note this will be the cross product of
        //the movement & the vertical axis, and will need to get updated whenever we
        //rotate about the vertical axis.
        vector< vector<double> > turtleHorizontalAxisStack;
        //Stores the sizes (the amount to step when interpreting) of a particular element
        //If a size is missing for an element, atomicSize is used
        map<string,double> elementSize;
        //if we turn, we don't need to step? (actually it's probably more complicated. oh well)
        bool justTurned;

        unsigned int currentSystemIndex;
        unsigned int bracketCount;
        string startMovementVectorKey;
    };
};
#endif
