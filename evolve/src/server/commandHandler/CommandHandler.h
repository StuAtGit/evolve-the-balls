#ifndef STU_COMMAND_HANDLER_H
#define STU_COMMAND_HANDLER_H

#include <map>

#include "CommonAspect.h"
#include "Mutex.h"
#include "ReadWriteLock.h"
#include "SocketMethods.h"
#include "Utility.h"

#define EXPORT __attribute__ ((visibility("default")))
//#define LOCAL __attribute__  ((visibility("hidden")))
#define LOCAL 

using namespace evolve;
/**
 * This class abstracts out the specific functionality for a particular type of server
 * For example, a server that handles lsystem objects would extend this and be an LSystemCommandHandler.
 * Any command handler is responsible for tracking whatever data it contains, and locking access
 * to that data appropriately. There is one command handler per server, and the methods may be
 * called from several threads.
 * Also allows a library to be updated without recompiling the server
 * */
namespace evolve
{

    class EXPORT CommandHandler : public CommonAspect 
    {
    public:
        CommandHandler();
        LOCAL virtual ~CommandHandler() { /*delete mutexes here..*/ };
         /**
        * The generic entry point for a command handler library
        * @param command the command you wish to perform 
        * @param id if your performing an operation on a particular object, this is the id of the object
        * @parm sock the client socket, so you can communicate with it
        */
        EXPORT virtual bool handleCommand( const string& command, const string& id, int sock, bool printDebug );
    
    protected:
        /**
         * The below are CONVIENCE methods. They do assume a particular type of implementation
         * (a map<string,object*> of some type of object. And that the user will respect
         * the mutexes, readWriteLock that they inherit appropriately.
         * If you try to use them, but have to do workarounds, just DON'T USE THEM.
         * */
        template <class S>
        bool checkIdExists( const string& id,const map<string,S>& container, const string& operation, int sock, bool printDebug = DO_DEBUG )
        {
            logger.print( "Notify: entered CommandHandler::checkIdExists", this->doNotify && printDebug );
            //the weakest locking available for the data structure
            this->readWriteLock.readLock();
            if( container.find( id ) == container.end() )
            {
                this->readWriteLock.unlock();
                string warning = "Warning: tried to use: " + operation + " on an object with " + id + " that does not exist, try creating it first";
                this->socketMethods.write( sock, warning, printDebug ); 
                logger.print( warning, printDebug );
                return false;
            }
            this->readWriteLock.unlock();
            return true;
    
        }
        template <class T>
        bool checkIdDoesNotExist( const string& id, const map<string,T>& container, const string& operation, int sock, bool printDebug = DO_DEBUG )
        {
            logger.print( "Notify: entered SystemCommandHandler::checkSystemDoesNotExist", this->doNotify && printDebug );
            //the weakest locking available for the data structure
            this->readWriteLock.readLock();
            if( container.find( id ) != container.end() )
            {
                this->readWriteLock.unlock();
                string warning = "Warning: can't " + operation + " since a system with that id: " + id + " already exists";
                this->socketMethods.write( sock, warning, printDebug ); 
                logger.print( warning, printDebug );
                return false;
            }
            this->readWriteLock.unlock();
            return true;
        }
        template <class K, class V>
        LOCAL bool getMap( map<K,V>& Map, const string& request, int sock, bool printDebug = DO_DEBUG )
        {
            this->logger.print( "Notify: entered CommandHandler::getMap", this->doNotify && printDebug );
            //we check this mainly in case a SIGPIPE happened..
            //(So we don't keep writing, a hopefully, neither does the caller)
            if( !this->socketMethods.write( sock, request, printDebug ) )
            {
                this->logger.print( "Error: in CommandHandler::getMap, write failed" );
                return false;
            }
            string reply = "";
            this->socketMethods.recieve( sock, reply, printDebug );
            bool success = false;
            Map = Utility::parseMap<K,V>( reply, success, printDebug ); 
            if( !success )
            {
                string error = "Warning: in CommandHandler::getMap: " + request +  
                            " requires a map in the default form generated by Utility::mapToString, " 
                            + reply + " was not in this form.";
                logger.print( error, printDebug );
                this->socketMethods.write( sock, error, printDebug );
                return false;
            }
    
            return true;   
        }
        template <class U>
        LOCAL bool getBasicType( U& t, const string& request, int sock, bool printDebug = DO_DEBUG )
        {
            this->logger.print( "Notify: entered CommandHandler::getBasicType", this->doNotify && printDebug );
            //we check this mainly in case a SIGPIPE happened..
            //(So we don't keep writing, and hopefully, neither does the caller)
            if( !this->socketMethods.write( sock, request, printDebug ) )
            {
                this->logger.print( "Error: in CommandHandler::getMap, write failed" );
                return false;
            }
            string reply = "";
            this->socketMethods.recieve( sock, reply, printDebug );
            bool success = false;
            t = Utility::stringTo<U>( reply, success, printDebug );
            if( !success )
            {
                string error = "Warning: in CommandHandler::getBasicType: " + request +  
                            " requires a type id typeid of: "  
                            + lexical_cast<string>( typeid( U ).name() )+ " but the reply was: " + reply ;
                logger.print( error, printDebug );
                this->socketMethods.write( sock, error, printDebug );
                return false;
            }
            return true;
        }
    
        /**
         * Here we lock for a mutex associated with the given id, and
         * We take out a read lock for the whole container (so no one
         * writes to the container while we're messing with the individual element
         * that is protected by a mutex with the give id - assuming, of course, they
         * are well-behaved, and try to acquire a writeLock before writing to the container)
         * We take out a mutex lock for the particular element we are working on, so other 
         * people can try to acquire the mutex to make sure that we're not messing with the
         * element while they are.
         * Thus, we don't prevent other people from messing around with other elements
         * in the container, as long as they don't touch us, or alter the container.
         * 
         * For container operations (like adding or deleting
         * elements), one MUST take out a writeLock on the 
         * container via this->readWriteLock.writeLock(), for this
         * scenario to work
         */
        LOCAL bool lock( const string& id, bool printDebug );
        LOCAL bool unlock( const string& id, bool printDebug );
        /**
         * simple method that writes the success or error message depending on the success flag
         * The downside to this method is the user may tend to flip success and error messages 
         * without thinking (I did)
         */
        LOCAL bool replyToUser( int sock, string successMsg, string errorMessage, bool success, bool printDebug );
        map<string,Mutex> mutexes;
        SocketMethods socketMethods;
        ReadWriteLock readWriteLock;
        Commands* commands;
        
    };
    
};

extern "C"
{
    /**
    * Entry points in the shared object to deal with name-mangling, creates
    * a DefaultCommandHanlder object and returns it
    * */
    EXPORT CommandHandler* createCommandHandlerObject();
    /**
    * Entry point in the dll to destroy the object, attempts to downcast the object
    * to the correct type (in this case, a DefaultCommandHanlder)
     * and then delete it using the appropriate destructor
     */
    EXPORT bool destroyCommandHandlerObject( CommandHandler*& obj );
}

#endif 
